# 10. 시스템 설계 & 확장성

## Q10-1. 시스템을 확장하려면 어떻게 해야 할까요?

### 답변 포인트
- 마이크로서비스 전환: 도메인별 독립 배포
- API Gateway 도입: 중앙 집중형 라우팅
- 메시지 큐 도입: 비동기 작업 처리
- 읽기 전용 레플리카: 읽기 작업 분산

### 상세 답변

#### 1. 마이크로서비스 전환
**현재 구조**: 모놀리식 아키텍처

**전환 방향**:
```
모놀리식 애플리케이션
  ↓
도메인별 독립 서비스 분리
  ↓
- User Service
- Board Service
- Chat Service
- Location Service
- Notification Service
```

**장점**:
- 도메인별 독립 배포
- 기술 스택 자유로운 선택
- 장애 격리
- 팀별 독립 개발

**고려사항**:
- 분산 트랜잭션 처리
- 서비스 간 통신 오버헤드
- 데이터 일관성 관리

#### 2. API Gateway 도입
**목적**: 중앙 집중형 라우팅 및 인증

**구조**:
```
클라이언트
  ↓
API Gateway (Spring Cloud Gateway)
  ↓
- User Service
- Board Service
- Chat Service
- ...
```

**기능**:
- 라우팅 및 로드 밸런싱
- 인증/인가 중앙 처리
- Rate Limiting
- 로깅 및 모니터링

**구현 예시**:
```yaml
# application.yml (API Gateway)
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
        - id: board-service
          uri: lb://BOARD-SERVICE
          predicates:
            - Path=/api/boards/**
```

#### 3. 메시지 큐 도입
**목적**: 비동기 작업 처리 및 서비스 간 통신

**구조**:
```
Board Service
  ↓
RabbitMQ / Kafka
  ↓
- Notification Service (알림 전송)
- Statistics Service (통계 집계)
```

**사용 시나리오**:
- 게시글 작성 시 알림 전송
- 댓글 작성 시 알림 전송
- 통계 데이터 집계

**장점**:
- 느슨한 결합
- 비동기 처리로 응답 시간 단축
- 장애 격리

#### 4. 읽기 전용 레플리카
**목적**: 읽기 작업 분산

**구조**:
```
애플리케이션
  ↓
쓰기: Primary DB
읽기: Read Replica 1, 2, 3
```

**구현**:
- Spring Data JPA의 `@Transactional(readOnly = true)` 활용
- AbstractRoutingDataSource로 동적 데이터소스 라우팅

**효과**:
- 읽기 성능 향상
- Primary DB 부하 감소

---

## Q10-2. 캐싱 전략을 어떻게 설계했나요?

### 답변 포인트
- Redis 캐싱: 알림, 인기글, 위치 서비스
- Spring Cache: 자주 조회되는 데이터
- TTL 관리: 데이터 특성에 따른 만료 시간 설정
- 캐시 무효화 전략: @CacheEvict 활용

### 상세 답변

#### 1. Redis 캐싱
**위치**: `PetoryApplication.java` (`@EnableCaching`)

**캐싱 대상**:
- 알림: 최신 50개 (TTL 24시간)
- 인기글 스냅샷: 주간/월간 (TTL 1시간)
- 위치 서비스: 카테고리별 인기 서비스 (TTL 1시간)

**코드 예시**:
```java
// domain/board/service/BoardService.java
@Cacheable(value = "boardDetail", key = "#idx")
public BoardDTO getBoard(long idx, Long viewerId) {
    // ...
}

@CacheEvict(value = "boardDetail", key = "#idx")
public BoardDTO updateBoard(long idx, BoardDTO dto) {
    // ...
}
```

#### 2. TTL 관리
**전략**: 데이터 특성에 따른 만료 시간 설정

**설정 예시**:
```properties
# application.properties
spring.cache.redis.time-to-live=3600000  # 1시간
```

**데이터별 TTL**:
- 알림: 24시간 (자주 변경되지 않음)
- 인기글: 1시간 (주기적으로 갱신)
- 사용자 정보: 1시간 (로그인 정보)

#### 3. 캐시 무효화 전략
**전략**: 데이터 변경 시 즉시 캐시 무효화

**코드 예시**:
```java
// 단일 캐시 무효화
@CacheEvict(value = "boardDetail", key = "#idx")
public void deleteBoard(long idx) {
    // ...
}

// 전체 캐시 무효화
@CacheEvict(value = "boardList", allEntries = true)
public BoardDTO createBoard(BoardDTO dto) {
    // ...
}

// 여러 캐시 동시 무효화
@Caching(evict = {
    @CacheEvict(value = "boardDetail", key = "#idx"),
    @CacheEvict(value = "boardList", allEntries = true)
})
public BoardDTO updateBoard(long idx, BoardDTO dto) {
    // ...
}
```

#### 4. 캐시 워밍
**전략**: 애플리케이션 시작 시 미리 캐시 로드

**구현 예시**:
```java
@Component
public class CacheWarmer implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) {
        // 인기글 스냅샷 미리 로드
        boardPopularityService.getPopularBoards(PopularityPeriodType.WEEKLY);
        
        // 위치 서비스 인기 목록 미리 로드
        locationServiceService.getPopularLocationServices("카페");
    }
}
```

---

## Q10-3. 대용량 트래픽을 처리하기 위한 전략은?

### 답변 포인트
- 읽기 전용 레플리카로 읽기 작업 분산
- CDN 도입으로 정적 리소스 배포
- 쿼리 최적화 및 인덱싱
- 캐싱 전략 강화

### 상세 답변

#### 1. 읽기 전용 레플리카
**구조**:
```
Primary DB (쓰기)
  ↓ 복제
Read Replica 1 (읽기)
Read Replica 2 (읽기)
Read Replica 3 (읽기)
```

**구현**:
```java
// 읽기 전용 트랜잭션은 Read Replica로 라우팅
@Transactional(readOnly = true)
public List<BoardDTO> getAllBoards() {
    // Read Replica에서 조회
}

// 쓰기 트랜잭션은 Primary DB로 라우팅
@Transactional
public BoardDTO createBoard(BoardDTO dto) {
    // Primary DB에 저장
}
```

#### 2. CDN 도입
**목적**: 정적 리소스 배포 및 캐싱

**구조**:
```
사용자
  ↓
CDN (CloudFlare, AWS CloudFront)
  ↓
- 이미지, CSS, JavaScript
- 정적 HTML
```

**효과**:
- 응답 시간 단축
- 서버 부하 감소
- 글로벌 배포

#### 3. 쿼리 최적화
**전략**:
- N+1 문제 해결 (Fetch Join, 배치 조회)
- 인덱스 전략 수립
- 불필요한 컬럼 제외 (Projection)

**효과**:
- 쿼리 실행 시간 단축
- DB 부하 감소

#### 4. 로드 밸런서
**구조**:
```
사용자
  ↓
로드 밸런서 (Nginx, AWS ALB)
  ↓
- 서버 1
- 서버 2
- 서버 3
```

**효과**:
- 트래픽 분산
- 장애 대응 (자동 페일오버)
- 무중단 배포

---

## Q10-4. 모니터링과 로깅 전략은?

### 답변 포인트
- 애플리케이션 모니터링: Prometheus + Grafana
- 로그 집계: ELK Stack
- 분산 추적: Zipkin 또는 Jaeger
- 성능 프로파일링

### 상세 답변

#### 1. 애플리케이션 모니터링
**도구**: Prometheus + Grafana

**구조**:
```
애플리케이션
  ↓
Prometheus (메트릭 수집)
  ↓
Grafana (시각화)
```

**모니터링 항목**:
- CPU, 메모리 사용률
- JVM 힙 메모리
- HTTP 요청 수/응답 시간
- DB 연결 풀 상태
- 에러율

#### 2. 로그 집계
**도구**: ELK Stack (Elasticsearch, Logstash, Kibana)

**구조**:
```
애플리케이션 (Logback)
  ↓
Logstash (수집 및 변환)
  ↓
Elasticsearch (저장 및 검색)
  ↓
Kibana (시각화 및 분석)
```

**로그 레벨**:
- ERROR: 즉시 대응 필요
- WARN: 주의 필요
- INFO: 일반 정보
- DEBUG: 디버깅 정보

#### 3. 분산 추적
**도구**: Spring Cloud Sleuth + Zipkin

**목적**: 마이크로서비스 간 요청 추적

**구조**:
```
API Gateway
  ↓ Trace ID: abc123
User Service
  ↓ Trace ID: abc123, Span ID: 1
Board Service
  ↓ Trace ID: abc123, Span ID: 2
Zipkin (추적 데이터 저장 및 시각화)
```

#### 4. 알림 설정
**도구**: Grafana Alerting

**알림 조건**:
- CPU 사용률 > 80% (5분 이상)
- 메모리 사용률 > 90%
- 에러율 > 5%
- 응답 시간 > 3초

---

## Q10-5. 데이터베이스 부하를 줄이기 위한 전략은?

### 답변 포인트
- 인덱스 전략 수립
- 쿼리 최적화 (N+1 문제 해결)
- 캐싱 활용
- 읽기 전용 레플리카
- 스냅샷 패턴으로 사전 집계

### 상세 답변

#### 1. 인덱스 전략
**전략**: 자주 조회되는 컬럼에 인덱스 생성

**인덱스 종류**:
- UNIQUE 인덱스: email, nickname
- 복합 인덱스: (is_deleted, created_at)
- FULLTEXT 인덱스: 게시글 제목, 내용

**주의사항**:
- 인덱스가 많으면 쓰기 성능 저하
- 선택도가 높은 컬럼에 인덱스 생성

#### 2. 쿼리 최적화
**전략**:
- Fetch Join으로 N+1 문제 해결
- 배치 조회로 IN 절 활용
- Projection으로 필요한 컬럼만 조회

**효과**:
- 쿼리 실행 시간 단축
- DB 부하 감소

#### 3. 캐싱 활용
**전략**:
- Redis로 자주 조회되는 데이터 캐싱
- TTL 설정으로 메모리 관리

**캐싱 대상**:
- 알림, 인기글, 위치 서비스
- 사용자 정보

#### 4. 읽기 전용 레플리카
**전략**: 읽기 작업을 레플리카로 분산

**구현**:
```java
@Transactional(readOnly = true)  // Read Replica로 라우팅
public List<BoardDTO> getAllBoards() {
    // ...
}
```

#### 5. 스냅샷 패턴
**전략**: 복잡한 계산 결과를 미리 생성하여 저장

**사용 사례**:
- 인기글 스냅샷 (BoardPopularitySnapshot)
- 통계 집계 (Statistics)

**효과**:
- 조회 시 복잡한 계산 불필요
- DB 부하 대폭 감소

---

## 📝 핵심 정리

### 시스템 확장
- **마이크로서비스**: 도메인별 독립 배포
- **API Gateway**: 중앙 집중형 라우팅
- **메시지 큐**: 비동기 작업 처리
- **읽기 레플리카**: 읽기 작업 분산

### 캐싱 전략
- **Redis 캐싱**: 알림, 인기글, 위치 서비스
- **TTL 관리**: 데이터 특성에 따른 설정
- **캐시 무효화**: @CacheEvict 활용

### 대용량 트래픽
- **읽기 레플리카**: 읽기 작업 분산
- **CDN**: 정적 리소스 배포
- **쿼리 최적화**: N+1 문제 해결
- **로드 밸런서**: 트래픽 분산

### 모니터링 & 로깅
- **Prometheus + Grafana**: 애플리케이션 모니터링
- **ELK Stack**: 로그 집계
- **Zipkin**: 분산 추적
- **알림 설정**: 장애 조기 감지

### DB 부하 감소
- **인덱스 전략**: 자주 조회되는 컬럼
- **쿼리 최적화**: Fetch Join, 배치 조회
- **캐싱**: Redis 활용
- **스냅샷 패턴**: 사전 집계
