# 5. 동시성 제어

## Q5-1. 동시성 문제가 발생할 수 있는 시나리오를 설명해주세요.

### 답변 포인트
- 여러 관리자가 동시에 같은 사용자에게 경고 부여
- 같은 소셜 계정으로 동시에 여러 번 로그인 시도
- 모임 참여 시 인원 초과 문제
- 펫케어 요청 확정 시 중복 확정 문제

### 상세 답변

#### 1. 경고 부여 동시성 문제
**시나리오**: 여러 관리자가 동시에 같은 사용자에게 경고 부여

**문제**:
```
관리자 A: warningCount 읽기 (현재: 2)
관리자 B: warningCount 읽기 (현재: 2)
관리자 A: warningCount = 2 + 1 = 3 저장
관리자 B: warningCount = 2 + 1 = 3 저장

결과: warningCount = 3 (실제로는 4가 되어야 함) - Lost Update 발생
```

**위치**: `domain/user/service/UserSanctionService.java`
**메서드**: `addWarning()`

#### 2. 소셜 로그인 동시성 문제
**시나리오**: 같은 소셜 계정으로 동시에 여러 번 로그인 시도

**문제**:
```
요청 A: 소셜 계정 조회 (없음)
요청 B: 소셜 계정 조회 (없음)
요청 A: 새 계정 생성
요청 B: 새 계정 생성

결과: 중복 계정 생성 - UNIQUE 제약조건 위반
```

**위치**: `domain/user/entity/SocialUser.java`

#### 3. 모임 참여 동시성 문제
**시나리오**: 모임 최대 인원 10명, 현재 9명일 때 동시에 2명이 참여

**문제**:
```
사용자 A: 현재 인원 확인 (9명)
사용자 B: 현재 인원 확인 (9명)
사용자 A: 참여 (10명)
사용자 B: 참여 (11명) - 최대 인원 초과
```

**위치**: `domain/meetup/service/MeetupService.java`

#### 4. 펫케어 요청 확정 동시성 문제
**시나리오**: 펫케어 요청에 동시에 여러 명이 확정 요청

**문제**:
```
사용자 A: 요청 상태 확인 (PENDING)
사용자 B: 요청 상태 확인 (PENDING)
사용자 A: 확정 (CONFIRMED)
사용자 B: 확정 (CONFIRMED) - 중복 확정
```

**위치**: `domain/care/service/CareRequestService.java`

---

## Q5-2. Lost Update 문제를 어떻게 해결했나요?

### 답변 포인트
- **문제**: 여러 스레드가 동시에 같은 값을 읽고 증가시키면 값이 누락됨
- **해결**: DB 레벨에서 원자적 증가 쿼리 사용

### 상세 답변

#### 1. 문제 상황
**위치**: `domain/user/service/UserSanctionService.java`
**메서드**: `addWarning()` (최적화 전)

**Before 해결**:
```java
// 문제가 있는 코드 (예시)
Users user = usersRepository.findById(userId);
int currentCount = user.getWarningCount();
user.setWarningCount(currentCount + 1);
usersRepository.save(user);
```

**문제점**:
- 여러 스레드가 동시에 같은 값을 읽음
- 각각 증가시켜 저장하면 값이 누락됨

#### 2. 해결 방법: 원자적 증가 쿼리
**위치**: `domain/user/repository/SpringDataJpaUsersRepository.java`
**메서드**: `incrementWarningCount()`

**전체 흐름**:
```
UserSanctionService.addWarning()
  ↓
UsersRepository.incrementWarningCount()
  ↓
DB 레벨에서 원자적 증가 쿼리 실행
  ↓
경고 횟수 정확하게 증가
```

**코드 예시**:
```java
// domain/user/repository/SpringDataJpaUsersRepository.java
@Modifying
@Query("UPDATE Users u SET u.warningCount = u.warningCount + 1 WHERE u.idx = :userId")
int incrementWarningCount(@Param("userId") Long userId);
```

**사용 예시**:
```java
// domain/user/service/UserSanctionService.java
@Transactional
public UserSanction addWarning(Long userId, String reason, Long adminId, Long reportId) {
    // 경고 추가
    UserSanction warning = UserSanction.builder()
        .user(user)
        .sanctionType(UserSanction.SanctionType.WARNING)
        .reason(reason)
        .build();
    sanctionRepository.save(warning);
    
    // 경고 횟수 원자적 증가 (동시성 문제 해결)
    usersRepository.incrementWarningCount(userId);
    
    // 업데이트된 사용자 정보 다시 조회
    user = usersRepository.findById(userId)
        .orElseThrow(() -> new IllegalArgumentException("유저를 찾을 수 없습니다."));
    
    // 경고 3회 이상이면 자동 이용제한
    if (user.getWarningCount() >= WARNING_THRESHOLD) {
        addSuspension(userId, "경고 누적으로 인한 자동 이용제한", adminId, reportId, 3);
    }
    
    return warning;
}
```

#### 3. 동작 원리
**DB 레벨 원자성**:
- UPDATE 쿼리는 DB 레벨에서 원자적으로 실행
- 여러 요청이 동시에 들어와도 순차적으로 처리
- Lost Update 문제 해결

**효과**:
- 경고 횟수가 정확하게 증가
- 자동 이용제한이 정확히 한 번만 적용
- 동시성 문제 완전 해결

---

## Q5-3. 소셜 로그인 동시성 문제를 어떻게 해결했나요?

### 답변 포인트
- **문제**: 같은 소셜 계정으로 동시에 여러 번 로그인 시도 시 중복 계정 생성
- **해결**: 
  - DB UNIQUE 제약조건 (Users.email, SocialUser.provider + providerId)
  - 트랜잭션 격리 수준 활용
  - 중복 생성 시도 시 DB 제약조건 위반 예외 발생

### 상세 답변

#### 1. UNIQUE 제약조건 설정
**위치**: `domain/user/entity/Users.java`, `domain/user/entity/SocialUser.java`

**Users 엔티티**:
```java
@Column(unique = true)
private String email;
```

**SocialUser 엔티티**:
```java
@Table(uniqueConstraints = {
    @UniqueConstraint(columnNames = {"provider", "providerId"})
})
public class SocialUser {
    private String provider;
    private String providerId;
}
```

#### 2. 트랜잭션 처리
**위치**: `domain/user/service/OAuth2UserService.java`

**전체 흐름**:
```
소셜 로그인 요청
  ↓
@Transactional 트랜잭션 시작
  ↓
SocialUser 조회 시도
  ↓
없으면 새 계정 생성 시도
  ↓
UNIQUE 제약조건 위반 시 예외 발생
  ↓
예외 처리: 기존 계정 조회 후 반환
```

**코드 예시**:
```java
@Transactional
public Users processOAuth2User(OAuth2UserRequest oAuth2UserRequest, OAuth2User oAuth2User) {
    try {
        // 새 계정 생성 시도
        SocialUser socialUser = SocialUser.builder()
            .provider(provider)
            .providerId(providerId)
            .build();
        return socialUserRepository.save(socialUser);
    } catch (DataIntegrityViolationException e) {
        // UNIQUE 제약조건 위반 시 기존 계정 조회
        return socialUserRepository.findByProviderAndProviderId(provider, providerId)
            .orElseThrow();
    }
}
```

#### 3. 효과
- 중복 계정 생성 방지
- 동시성 문제 해결
- DB 제약조건으로 안전성 보장

---

## Q5-4. 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)의 차이는?

### 답변 포인트
- **낙관적 락**: @Version 필드로 버전 관리, 충돌 시 예외 발생
- **비관적 락**: DB 레벨에서 락 획득, SELECT FOR UPDATE
- 프로젝트에서는 주로 DB 제약조건과 원자적 쿼리 활용

### 상세 답변

#### 1. 낙관적 락 (Optimistic Lock)
**동작 방식**:
- `@Version` 필드로 버전 관리
- 읽기 시 버전 저장
- 수정 시 버전 비교
- 버전이 다르면 예외 발생

**장점**:
- 읽기 성능 우수
- 락 대기 시간 없음

**단점**:
- 충돌 시 재시도 필요
- 구현 복잡

**프로젝트 사용 여부**: 사용하지 않음

#### 2. 비관적 락 (Pessimistic Lock)
**동작 방식**:
- `SELECT FOR UPDATE`로 락 획득
- 다른 트랜잭션은 대기
- 커밋 시 락 해제

**장점**:
- 충돌 방지
- 구현 간단

**단점**:
- 읽기 성능 저하
- 데드락 가능성

**프로젝트 사용 여부**: 사용하지 않음

#### 3. 프로젝트에서 사용한 방법
**DB 제약조건 + 원자적 쿼리**:
- UNIQUE 제약조건: 중복 방지
- 원자적 증가 쿼리: Lost Update 해결
- 트랜잭션 격리 수준: READ_COMMITTED

**예시**:
```java
// 원자적 증가 쿼리
@Modifying
@Query("UPDATE Users u SET u.warningCount = u.warningCount + 1 WHERE u.idx = :userId")
int incrementWarningCount(@Param("userId") Long userId);
```

**효과**:
- 구현 간단
- 성능 우수
- 동시성 문제 해결

---

## Q5-5. 모임 참여 시 동시성 문제를 어떻게 해결했나요?

### 답변 포인트
- 트랜잭션 내에서 인원 수 확인 및 증가
- DB 제약조건으로 최대 인원 초과 방지
- Race Condition 방지를 위한 원자적 연산

### 상세 답변

#### 1. 문제 상황
**시나리오**: 모임 최대 인원 10명, 현재 9명일 때 동시에 2명이 참여

**Before 해결**:
```java
// 문제가 있는 코드 (예시)
Meetup meetup = meetupRepository.findById(meetupId);
if (meetup.getCurrentParticipants() < meetup.getMaxParticipants()) {
    meetup.setCurrentParticipants(meetup.getCurrentParticipants() + 1);
    meetupRepository.save(meetup);
}
```

**문제점**:
- 여러 요청이 동시에 인원 수 확인
- 각각 증가시켜 저장하면 최대 인원 초과 가능

#### 2. 해결 방법
**위치**: `domain/meetup/service/MeetupService.java`

**전체 흐름**:
```
모임 참여 요청
  ↓
@Transactional 트랜잭션 시작
  ↓
모임 정보 조회
  ↓
인원 수 확인 및 증가 (원자적 연산)
  ↓
DB 제약조건으로 최대 인원 초과 방지
```

**코드 예시**:
```java
@Transactional
public void joinMeetup(Long meetupId, Long userId) {
    Meetup meetup = meetupRepository.findById(meetupId)
        .orElseThrow(() -> new IllegalArgumentException("모임을 찾을 수 없습니다."));
    
    // 트랜잭션 내에서 인원 수 확인
    if (meetup.getCurrentParticipants() >= meetup.getMaxParticipants()) {
        throw new IllegalStateException("모임 인원이 가득 찼습니다.");
    }
    
    // 인원 수 증가
    meetup.setCurrentParticipants(meetup.getCurrentParticipants() + 1);
    meetupRepository.save(meetup);
    
    // 참여자 추가
    MeetupParticipant participant = MeetupParticipant.builder()
        .meetup(meetup)
        .user(user)
        .build();
    meetupParticipantRepository.save(participant);
}
```

#### 3. DB 제약조건
**위치**: `domain/meetup/entity/Meetup.java`

**코드 예시**:
```java
@Column(nullable = false)
private Integer maxParticipants;

@Column(nullable = false)
private Integer currentParticipants;
```

**추가 보호**:
- 애플리케이션 레벨 체크
- DB 제약조건으로 이중 보호

#### 4. 효과
- 최대 인원 초과 방지
- 동시성 문제 해결
- Race Condition 방지

---

## 📝 핵심 정리

### 동시성 문제 시나리오
- **경고 부여**: 여러 관리자 동시 경고 부여
- **소셜 로그인**: 같은 계정 동시 로그인
- **모임 참여**: 인원 초과 문제
- **펫케어 확정**: 중복 확정 문제

### Lost Update 해결
- **원자적 증가 쿼리**: DB 레벨에서 원자적 연산
- **위치**: `UsersRepository.incrementWarningCount()`
- **효과**: 경고 횟수 정확하게 증가

### 소셜 로그인 동시성 해결
- **UNIQUE 제약조건**: `provider + providerId` 조합
- **예외 처리**: 중복 시 기존 계정 조회
- **효과**: 중복 계정 생성 방지

### 락 전략
- **낙관적 락**: @Version 필드 (사용 안 함)
- **비관적 락**: SELECT FOR UPDATE (사용 안 함)
- **프로젝트 방법**: DB 제약조건 + 원자적 쿼리

### 모임 참여 동시성 해결
- **트랜잭션 내 확인**: 인원 수 확인 및 증가
- **DB 제약조건**: 최대 인원 초과 방지
- **효과**: Race Condition 방지
