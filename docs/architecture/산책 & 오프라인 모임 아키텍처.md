# 산책 & 오프라인 모임 (Meetup) 아키텍처

## 📋 개요

산책 & 오프라인 모임 도메인은 반려동물 산책 모임을 생성하고 참여할 수 있는 기능을 제공하는 핵심 도메인입니다. 위치 기반 검색, 최대 인원 제한, 채팅방 자동 연동 등을 통해 사용자들이 오프라인에서 만날 수 있는 모임을 쉽게 만들고 참여할 수 있도록 합니다.

## 🏗️ 시스템 아키텍처

### 전체 구조도

```mermaid
graph TB
    subgraph "Frontend"
        FE[React Frontend<br/>MeetupPage 컴포넌트]
    end
    
    subgraph "Backend API Layer"
        MC[MeetupController<br/>/api/meetups]
    end
    
    subgraph "Service Layer"
        MS[MeetupService<br/>모임 CRUD, 참여 관리]
        CS[ConversationService<br/>채팅방 자동 생성/연동]
    end
    
    subgraph "Data Layer"
        MR[MeetupRepository]
        MPR[MeetupParticipantsRepository]
        MySQL[(MySQL<br/>Meetup<br/>MeetupParticipants)]
    end
    
    subgraph "External Integration"
        CHAT[Chat Domain<br/>그룹 채팅방 생성]
        USER[User Domain<br/>이메일 인증 확인]
    end
    
    FE -->|모임 생성/조회| MC
    FE -->|모임 참여/취소| MC
    
    MC --> MS
    MS --> MR
    MS --> MPR
    MS --> CS
    
    CS --> CHAT
    MS --> USER
    
    MR --> MySQL
    MPR --> MySQL
    
    style MS fill:#e1f5ff
    style CS fill:#fff4e1
    style USER fill:#ffe1f5
```

## 🔧 핵심 컴포넌트

### 1. MeetupService (모임 관리)

**역할**: 모임 CRUD, 참여 관리, 위치 기반 검색

**주요 메서드**:
- `createMeetup()`: 모임 생성 (이메일 인증 필수, 채팅방 자동 생성)
- `joinMeetup()`: 모임 참여 (최대 인원 제한, 동시성 제어)
- `cancelMeetupParticipation()`: 모임 참여 취소 (채팅방 자동 나가기)
- `getNearbyMeetups()`: 반경 기반 모임 검색 (Haversine 공식)

**핵심 로직**:

#### 모임 생성 프로세스
```java
@Transactional
public MeetupDTO createMeetup(MeetupDTO meetupDTO, String userId) {
    // 1. 이메일 인증 확인
    if (organizer.getEmailVerified() == null || !organizer.getEmailVerified()) {
        throw new EmailVerificationRequiredException("모임 생성을 위해 이메일 인증이 필요합니다.");
    }
    
    // 2. 날짜 검증
    if (meetupDTO.getDate().isBefore(LocalDateTime.now())) {
        throw new RuntimeException("모임 일시는 현재 시간 이후여야 합니다.");
    }
    
    // 3. 모임 생성
    Meetup meetup = Meetup.builder()
            .organizer(organizer)
            .currentParticipants(0)
            .status(MeetupStatus.RECRUITING)
            .build();
    
    // 4. 주최자 자동 참여
    MeetupParticipants organizerParticipant = MeetupParticipants.builder()
            .meetup(savedMeetup)
            .user(organizer)
            .build();
    savedMeetup.setCurrentParticipants(1);
    
    // 5. 그룹 채팅방 자동 생성 (주최자 ADMIN 역할)
    conversationService.createConversation(
        ConversationType.MEETUP,
        RelatedType.MEETUP,
        savedMeetup.getIdx(),
        savedMeetup.getTitle(),
        List.of(organizer.getIdx())
    );
    conversationService.setParticipantRole(
        RelatedType.MEETUP,
        savedMeetup.getIdx(),
        organizer.getIdx(),
        ParticipantRole.ADMIN
    );
}
```

#### 모임 참여 프로세스
```java
@Transactional
public MeetupParticipantsDTO joinMeetup(Long meetupIdx, String userId) {
    // 1. 이메일 인증 확인
    if (user.getEmailVerified() == null || !user.getEmailVerified()) {
        throw new EmailVerificationRequiredException("모임 참여를 위해 이메일 인증이 필요합니다.");
    }
    
    // 2. 중복 참여 체크
    if (meetupParticipantsRepository.existsByMeetupIdxAndUserIdx(meetupIdx, userIdx)) {
        throw new RuntimeException("이미 참가한 모임입니다.");
    }
    
    // 3. 최대 인원 체크 (주최자 제외)
    if (!meetup.getOrganizer().getIdx().equals(userIdx)) {
        if (meetup.getCurrentParticipants() >= meetup.getMaxParticipants()) {
            throw new RuntimeException("모임 인원이 가득 찼습니다.");
        }
    }
    
    // 4. 참가자 추가 및 인원 증가
    MeetupParticipants participant = MeetupParticipants.builder()
            .meetup(meetup)
            .user(user)
            .build();
    
    if (!meetup.getOrganizer().getIdx().equals(userIdx)) {
        meetup.setCurrentParticipants(meetup.getCurrentParticipants() + 1);
    }
}
```

#### 반경 기반 검색 (Haversine 공식)
```java
public List<MeetupDTO> getNearbyMeetups(Double lat, Double lng, Double radiusKm) {
    // Haversine 공식으로 거리 계산
    Function<Meetup, Double> calculateDistance = (meetup) -> {
        double lat1 = Math.toRadians(lat);
        double lat2 = Math.toRadians(meetup.getLatitude());
        double lon1 = Math.toRadians(lng);
        double lon2 = Math.toRadians(meetup.getLongitude());
        
        double dLat = lat2 - lat1;
        double dLon = lon2 - lon1;
        
        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return 6371 * c; // 지구 반지름 6371km
    };
    
    // 필터링: 좌표 있는 모임만, 미래 날짜만, COMPLETED 상태 제외
    // 정렬: 거리순 정렬, 같으면 날짜순 정렬
}
```

### 2. 상태 관리

**상태 전이**:
```
RECRUITING → CLOSED → COMPLETED
```

**상태 설명**:
- `RECRUITING`: 모집 중 (기본 상태)
- `CLOSED`: 마감 (최대 인원 도달 또는 수동 마감)
- `COMPLETED`: 종료 (모임 일시 지남)

**상태 전이 규칙**:
- 모임 생성 시: `RECRUITING` 상태로 시작
- 최대 인원 도달 시: `CLOSED` 상태로 변경 가능
- 모임 일시 지남: `COMPLETED` 상태로 변경 (자동 또는 수동)

### 3. 인원 관리

**인원 관리 로직**:
- 주최자는 자동으로 참가자에 포함 (`currentParticipants = 1`)
- 주최자는 `currentParticipants`에 포함되지 않음 (최대 인원 체크 시 제외)
- 참여 시: 주최자가 아닌 경우에만 `currentParticipants` 증가
- 참여 취소 시: `currentParticipants` 감소 (최소 0)

**동시성 제어**:
- `@Transactional`로 트랜잭션 보장
- 중복 참여 체크: `existsByMeetupIdxAndUserIdx()`로 DB 레벨 체크
- 최대 인원 체크: 트랜잭션 내에서 체크 및 증가

## 🔄 비즈니스 로직 흐름

### 1. 모임 생성 흐름

**단계별 처리 과정** (`MeetupService.createMeetup()`):

1. **이메일 인증 확인**
   - **이메일 인증 필수**: `organizer.getEmailVerified()` 확인
   - 미인증 시 `EmailVerificationRequiredException` 발생
   - 모임 생성은 책임 있는 행동이므로 2단계 권한 필요

2. **날짜 검증**
   - 모임 일시가 현재 시간 이후인지 확인
   - 과거 날짜면 예외 발생

3. **모임 저장**
   - 모임 정보 저장 (제목, 설명, 위치, 좌표, 날짜, 최대 인원 등)
   - 상태: 기본값 `RECRUITING` (모집 중)
   - `currentParticipants = 0`으로 초기화

4. **주최자 자동 참여**
   - `MeetupParticipants` 엔티티 생성하여 주최자를 참가자로 추가
   - `currentParticipants = 1`로 설정 (주최자 포함)

5. **이벤트 발행** (트랜잭션 커밋 후)
   - `TransactionSynchronization.afterCommit()`을 사용하여 트랜잭션 커밋 후 이벤트 발행
   - `MeetupCreatedEvent` 발행
   - 채팅방 생성 실패가 모임 생성까지 롤백하지 않도록 분리

6. **채팅방 자동 생성** (비동기, 별도 트랜잭션)
   - `MeetupChatRoomEventListener`가 이벤트 수신
   - `@Async`로 비동기 처리
   - `@Transactional(REQUIRES_NEW)`로 별도 트랜잭션
   - 그룹 채팅방 생성 (`ConversationType.MEETUP`)
   - 주최자를 `ADMIN` 역할로 설정
   - 채팅방 생성 실패해도 모임 생성은 유지

**특징:**
- 이메일 인증 필수
- 주최자 자동 참여
- 채팅방 생성은 이벤트 기반으로 분리 (핵심 도메인과 파생 도메인 분리)

### 2. 모임 참여 흐름

**단계별 처리 과정** (`MeetupService.joinMeetup()`):

1. **이메일 인증 확인**
   - **이메일 인증 필수**: `user.getEmailVerified()` 확인
   - 미인증 시 `EmailVerificationRequiredException` 발생

2. **중복 참여 확인**
   - `existsByMeetupIdxAndUserIdx()`로 DB 레벨 중복 체크
   - 이미 참여한 경우 예외 발생

3. **최대 인원 체크 및 증가** (원자적 UPDATE 쿼리)
   - 주최자가 아닌 경우에만 인원 증가
   - **원자적 UPDATE 쿼리**: `incrementParticipantsIfAvailable()`
     - `WHERE currentParticipants < maxParticipants` 조건으로 DB 레벨 체크
     - 조건 만족 시 `currentParticipants + 1` 증가 (원자적 연산)
   - 업데이트된 행 수가 0이면 인원 초과 예외 발생
   - 업데이트 후 모임 정보 다시 조회

4. **참가자 추가**
   - `MeetupParticipants` 엔티티 생성 및 저장
   - `joinedAt = LocalDateTime.now()` 기록

**동시성 제어:**
- 원자적 UPDATE 쿼리로 Race Condition 방지
- 여러 사용자가 동시에 참여해도 인원 수 정확성 보장

**특징:**
- 원자적 UPDATE 쿼리로 동시성 문제 해결
- 주최자는 최대 인원 체크에서 제외 (이미 참여한 상태)

### 3. 모임 참여 취소 흐름

**단계별 처리 과정** (`MeetupService.cancelMeetupParticipation()`):

1. **주최자 보호**
   - 주최자는 참여 취소 불가
   - 주최자가 취소하려 하면 예외 발생

2. **참가자 확인**
   - 참가 정보가 존재하는지 확인
   - 존재하지 않으면 예외 발생

3. **참가자 삭제**
   - `meetupParticipantsRepository.delete()`로 참가자 삭제

4. **인원 감소**
   - `currentParticipants` 1 감소
   - 최소값 0 보장 (`Math.max(0, currentParticipants - 1)`)

5. **채팅방 자동 나가기**
   - `conversationService.leaveMeetupChat()` 호출
   - 채팅방에서 자동으로 나가기
   - 채팅방 나가기 실패해도 모임 참여 취소는 성공으로 처리 (예외 캐치)

**특징:**
- 주최자 보호 (참여 취소 불가)
- 채팅방 자동 나가기 연동
- 채팅방 나가기 실패해도 모임 참여 취소는 성공

### 4. 반경 기반 모임 검색 흐름

**단계별 처리 과정** (`MeetupService.getNearbyMeetups()`):

1. **전체 모임 조회**
   - 소프트 삭제되지 않은 모든 모임 조회
   - Native query 문제 회피를 위해 Java에서 필터링

2. **Haversine 공식으로 거리 계산**
   - 각 모임의 좌표와 사용자 좌표 간 거리 계산
   - 지구 반지름: 6371km
   - 거리 정보를 `Map.Entry<Meetup, Double>` 형태로 저장

3. **필터링** (순차적 적용)
   - 좌표 확인: 위도/경도가 있는 모임만 포함
   - 날짜 필터: 미래 날짜만 포함 (`date > now`)
   - 상태 필터: `COMPLETED` 상태 제외
   - 반경 필터: 계산된 거리가 반경 이내인 모임만 포함

4. **정렬**
   - 거리순 정렬 (가까운 순)
   - 거리가 같으면 날짜순 정렬 (빠른 순)

5. **DTO 변환**
   - 필터링 및 정렬된 모임을 DTO로 변환하여 반환

**성능 로깅:**
- DB 쿼리 시간, 필터링/정렬 시간, DTO 변환 시간 측정
- 필터링 통계 (좌표 없음, 과거 날짜, COMPLETED, 반경 초과 등)

**특징:**
- 전체 조회 후 Java에서 필터링 (Native query 문제 회피)
- Haversine 공식으로 정확한 거리 계산
- 상세한 성능 및 필터링 통계 로깅

### 5. 모임 수정/삭제 흐름

**수정 흐름** (`MeetupService.updateMeetup()`):

1. **모임 조회**
   - 모임 존재 여부 확인

2. **데이터 업데이트**
   - 제목, 설명, 위치, 좌표, 날짜, 최대 인원 업데이트
   - null이 아닌 값만 업데이트

3. **응답 반환**
   - 업데이트된 모임 정보를 DTO로 변환하여 반환

**삭제 흐름** (`MeetupService.deleteMeetup()`):

1. **Soft Delete 처리**
   - `isDeleted = true` 설정
   - `deletedAt = LocalDateTime.now()` 기록
   - DB 저장

**특징:**
- Soft Delete 방식으로 데이터 보존
- 모임 수정 시 null이 아닌 값만 업데이트

## 📊 데이터 흐름

### 1. 모임 생성 및 채팅방 연동 흐름

```mermaid
sequenceDiagram
    participant User as 사용자
    participant Frontend
    participant MeetupController
    participant MeetupService
    participant ConversationService
    participant MySQL
    
    User->>Frontend: 모임 생성 요청
    Frontend->>MeetupController: POST /api/meetups
    MeetupController->>MeetupService: createMeetup()
    
    MeetupService->>MeetupService: 이메일 인증 확인
    MeetupService->>MeetupService: 날짜 검증
    
    MeetupService->>MySQL: INSERT Meetup (RECRUITING)
    MySQL-->>MeetupService: 저장 완료
    
    MeetupService->>MySQL: INSERT MeetupParticipants (주최자)
    MySQL-->>MeetupService: 저장 완료
    
    MeetupService->>MySQL: UPDATE Meetup (currentParticipants = 1)
    MySQL-->>MeetupService: 업데이트 완료
    
    MeetupService->>ConversationService: createConversation()
    ConversationService->>MySQL: INSERT Conversation (MEETUP)
    MySQL-->>ConversationService: 저장 완료
    
    ConversationService->>ConversationService: setParticipantRole(ADMIN)
    ConversationService->>MySQL: UPDATE ParticipantRole
    MySQL-->>ConversationService: 업데이트 완료
    
    MeetupService-->>Frontend: MeetupDTO 반환
```

### 2. 모임 참여 흐름

```mermaid
sequenceDiagram
    participant User as 사용자
    participant Frontend
    participant MeetupController
    participant MeetupService
    participant MySQL
    
    User->>Frontend: 모임 참여 요청
    Frontend->>MeetupController: POST /api/meetups/{id}/join
    MeetupController->>MeetupService: joinMeetup()
    
    MeetupService->>MeetupService: 이메일 인증 확인
    MeetupService->>MySQL: SELECT Meetup
    MySQL-->>MeetupService: Meetup 정보
    
    MeetupService->>MySQL: 중복 참여 체크
    MySQL-->>MeetupService: 중복 없음
    
    MeetupService->>MeetupService: 최대 인원 체크
    
    MeetupService->>MySQL: INSERT MeetupParticipants
    MySQL-->>MeetupService: 저장 완료
    
    MeetupService->>MySQL: UPDATE Meetup (currentParticipants++)
    MySQL-->>MeetupService: 업데이트 완료
    
    MeetupService-->>Frontend: MeetupParticipantsDTO 반환
```

### 3. 반경 기반 검색 흐름

```mermaid
sequenceDiagram
    participant User as 사용자
    participant Frontend
    participant MeetupController
    participant MeetupService
    participant MySQL
    
    User->>Frontend: 반경 기반 검색 요청
    Frontend->>MeetupController: GET /api/meetups/nearby?lat=&lng=&radius=
    MeetupController->>MeetupService: getNearbyMeetups()
    
    MeetupService->>MySQL: SELECT * FROM Meetup
    MySQL-->>MeetupService: 전체 모임 목록
    
    MeetupService->>MeetupService: Haversine 공식으로 거리 계산
    
    loop 각 모임마다
        MeetupService->>MeetupService: 좌표 확인
        MeetupService->>MeetupService: 미래 날짜 확인
        MeetupService->>MeetupService: COMPLETED 상태 제외
        MeetupService->>MeetupService: 반경 내 확인
    end
    
    MeetupService->>MeetupService: 거리순 정렬, 같으면 날짜순 정렬
    
    MeetupService-->>Frontend: List<MeetupDTO> 반환
```

## 🎯 핵심 설계 전략

### 1. 위치 기반 검색 전략

**문제**: 사용자 위치 기준으로 가까운 모임을 찾아야 함

**해결**: Haversine 공식 사용
- 지구를 구로 가정한 대원 거리 계산
- 지구 반지름: 6371km
- 미터 단위로 정확한 거리 계산

**필터링 조건**:
- 좌표가 있는 모임만 포함
- 미래 날짜만 포함 (`date > now`)
- `COMPLETED` 상태 제외

**정렬 전략**:
- 거리순 정렬 (가까운 순)
- 거리가 같으면 날짜순 정렬 (빠른 순)

**효과**:
- 사용자 위치 기준으로 가까운 모임 우선 표시
- 정확한 거리 계산으로 신뢰도 향상

### 2. 인원 관리 전략

**문제**: 최대 인원 제한을 정확하게 관리해야 함

**해결**: 주최자 제외 인원 관리
- 주최자는 자동으로 참가자에 포함되지만 `currentParticipants`에 포함되지 않음
- 최대 인원 체크 시 주최자 제외
- 참여 시 주최자가 아닌 경우에만 `currentParticipants` 증가

**동시성 제어**:
- `@Transactional`로 트랜잭션 보장
- 중복 참여 체크: DB 레벨 체크 (`existsByMeetupIdxAndUserIdx`)
- 최대 인원 체크: 트랜잭션 내에서 체크 및 증가

**효과**:
- 정확한 인원 수 관리
- 동시 참여 시에도 인원 수 정확성 보장

### 3. 채팅 연동 전략

**문제**: 모임 생성 시 자동으로 채팅방을 만들어야 함

**해결**: 모임 생성 시 그룹 채팅방 자동 생성
- 모임 생성 시 `ConversationService.createConversation()` 호출
- 주최자를 ADMIN 역할로 설정
- 참여 시 채팅방 자동 참여
- 참여 취소 시 채팅방 자동 나가기

**에러 처리**:
- 채팅방 생성 실패해도 모임 생성은 성공으로 처리
- 채팅방 나가기 실패해도 모임 참여 취소는 성공으로 처리

**효과**:
- 사용자 개입 없이 자동으로 채팅방 생성
- 모임 참여자 간 소통 편의성 향상

### 4. 이메일 인증 필수 전략

**문제**: 신뢰할 수 있는 사용자만 모임을 생성/참여해야 함

**해결**: 이메일 인증 필수
- 모임 생성 시 이메일 인증 확인
- 모임 참여 시 이메일 인증 확인
- 미인증 사용자는 모임 생성/참여 불가

**효과**:
- 신뢰할 수 있는 사용자만 서비스 이용
- 스팸 및 악의적 사용 방지

### 5. 상태 관리 전략

**문제**: 모임의 생애주기를 명확하게 관리해야 함

**해결**: 상태 기반 전이 관리
- `RECRUITING`: 모집 중 (기본 상태)
- `CLOSED`: 마감 (최대 인원 도달 또는 수동 마감)
- `COMPLETED`: 종료 (모임 일시 지남)

**상태 전이 규칙**:
- 모임 생성 시: `RECRUITING` 상태로 시작
- 최대 인원 도달 시: `CLOSED` 상태로 변경 가능
- 모임 일시 지남: `COMPLETED` 상태로 변경 (자동 또는 수동)

**효과**:
- 명확한 모임 상태 관리
- 사용자가 모임 상태를 쉽게 파악 가능

## 🔄 도메인 간 연동

### 1. Chat 도메인 연동
- **용도**: 모임 생성 시 그룹 채팅방 자동 생성 및 연동
- **방법**: `ConversationService.createConversation()`, `setParticipantRole()` 호출
- **효과**: 모임 참여자 간 소통 편의성 향상

### 2. User 도메인 연동
- **용도**: 이메일 인증 확인
- **방법**: `Users.emailVerified` 필드 확인
- **효과**: 신뢰할 수 있는 사용자만 서비스 이용

## 📈 성능 최적화

### 1. DB 최적화

#### 인덱스 전략
```sql
-- 주최자별 모임 조회
CREATE INDEX idx_meetup_organizer ON meetup(organizer_idx, created_at DESC);

-- 날짜별 모임 조회
CREATE INDEX idx_meetup_date ON meetup(date);

-- 상태별 모임 조회
CREATE INDEX idx_meetup_status ON meetup(status);

-- 위치 기반 검색 (위도/경도)
CREATE INDEX idx_meetup_location ON meetup(latitude, longitude);

-- 참가자 조회
CREATE INDEX idx_meetup_participants ON meetupparticipants(meetup_idx, user_idx);
```

**선정 이유**:
- 주최자별 조회가 빈번함
- 날짜별 필터링이 자주 사용됨
- 위치 기반 검색 최적화
- 참가자 조회 성능 향상

### 2. 애플리케이션 레벨 최적화

#### 반경 기반 검색 최적화
- **전체 조회 후 필터링**: Native query 문제 회피를 위해 Java에서 필터링
- **스트림 처리**: Java Stream API로 효율적인 필터링 및 정렬
- **거리 계산 캐싱**: 거리 계산 결과를 Map.Entry로 저장하여 재사용

#### 트랜잭션 관리
- `@Transactional`로 데이터 일관성 보장
- 읽기 전용 트랜잭션 (`@Transactional(readOnly = true)`) 사용

## 🔐 보안 고려사항

### 1. 권한 제어
- 모임 생성: 이메일 인증 필수
- 모임 참여: 이메일 인증 필수
- 모임 수정/삭제: 주최자만 가능 (추가 구현 필요)

### 2. 데이터 검증
- 날짜 검증: 모임 일시는 현재 시간 이후여야 함
- 중복 참여 방지: DB 레벨 체크
- 최대 인원 체크: 트랜잭션 내에서 체크

### 3. 입력 검증
- SQL Injection 방지 (JPA 사용)
- XSS 방지 (DTO 변환 시 이스케이프)

## 📝 주요 API 엔드포인트

### 모임 관리
```
GET /api/meetups
→ List<MeetupDTO>

GET /api/meetups/{id}
→ MeetupDTO

POST /api/meetups
→ MeetupDTO

PUT /api/meetups/{id}
→ MeetupDTO

DELETE /api/meetups/{id}
→ 204 No Content
```

### 모임 검색
```
GET /api/meetups/nearby?lat={위도}&lng={경도}&radius={반경km}
→ List<MeetupDTO>

GET /api/meetups/search?keyword={키워드}
→ List<MeetupDTO>

GET /api/meetups/location?minLat=&maxLat=&minLng=&maxLng=
→ List<MeetupDTO>
```

### 모임 참여
```
POST /api/meetups/{id}/join
→ MeetupParticipantsDTO

DELETE /api/meetups/{id}/join
→ 204 No Content

GET /api/meetups/{id}/participants
→ List<MeetupParticipantsDTO>
```

## 🎯 핵심 포인트 요약

### 1. 모임 생성 및 참여
- **생성**: 이메일 인증 필수, 주최자 자동 참여, 채팅방 자동 생성
- **참여**: 이메일 인증 필수, 최대 인원 제한, 동시성 제어
- **취소**: 주최자 보호, 채팅방 자동 나가기

### 2. 위치 기반 검색
- **Haversine 공식**: 지구 반지름 6371km 사용, 미터 단위 정확한 거리 계산
- **필터링**: 좌표 있는 모임만, 미래 날짜만, COMPLETED 상태 제외
- **정렬**: 거리순 정렬, 같으면 날짜순 정렬

### 3. 인원 관리
- **주최자 제외**: 주최자는 `currentParticipants`에 포함되지 않음
- **동시성 제어**: `@Transactional`로 트랜잭션 보장
- **정확한 인원 수**: 중복 참여 방지, 최대 인원 체크

### 4. 채팅 연동
- **자동 생성**: 모임 생성 시 그룹 채팅방 자동 생성
- **자동 참여**: 모임 참여 시 채팅방 자동 참여
- **자동 나가기**: 모임 참여 취소 시 채팅방 자동 나가기

### 5. 상태 관리
- **상태 전이**: RECRUITING → CLOSED → COMPLETED
- **명확한 규칙**: 각 상태별 명확한 전이 규칙
- **자동/수동**: 상태 변경은 자동 또는 수동으로 가능

### 6. 이메일 인증
- **필수 조건**: 모임 생성/참여 시 이메일 인증 필수
- **신뢰성**: 신뢰할 수 있는 사용자만 서비스 이용
- **보안**: 스팸 및 악의적 사용 방지
