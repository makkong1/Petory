# 채팅 시스템 설계

## 채팅 프로세스 흐름 (방안 2: 범용 구조)

### 1. 펫케어 요청 채팅 (CARE_REQUEST)

#### 방안 A: 댓글 기반 채팅 (현재 구현)

1. **펫케어 요청 작성 (CareRequest: OPEN)**
   - 보호자가 펫케어 요청 글을 작성하면 상태는 `OPEN`이 됨.

2. **펫시터가 댓글 작성**
   - `SERVICE_PROVIDER` 역할 사용자가 댓글(`CareRequestComment`) 작성.
   - 댓글은 지원 의사 표현 역할.
   - 보호자에게 "새로운 댓글이 달렸습니다" 알림이 발송됨.

3. **보호자가 댓글 작성자와 채팅 시작**
   - 보호자(게시글 작성자)에게 댓글에 "채팅하기" 버튼 표시.
   - 댓글 작성자 이름 클릭 시 프로필 모달 표시 (리뷰 정보 포함).
   - "채팅하기" 버튼 클릭 시 1:1 일반 채팅(`DIRECT`) 시작.
   - 기존 채팅방이 있으면 재사용, 없으면 새로 생성.

4. **채팅/협상**
   - 채팅방에서 메시지를 주고받으며 세부 조건을 협의.
   - 메시지 도착 시 실시간 알림.

5. **서비스 완료**
   - 서비스 완료 후 `CareRequest` 상태 `COMPLETED`로 변경.
   - 채팅방은 계속 활성 상태 유지.
   - 후기(`CareReview`) 작성 가능.

#### 방안 B: 지원 승인 기반 채팅 (향후 구현)

1. **펫케어 요청 작성 (CareRequest: OPEN)**
   - 보호자가 펫케어 요청 글을 작성하면 상태는 `OPEN`이 됨.

2. **펫시터가 '지원하기' 클릭**
   - 펫시터가 요청에 지원하면 `CareApplication`(지원) 레코드가 생성되고, 상태는 `PENDING`.
   - 보호자에게 "새로운 지원이 들어왔습니다" 알림이 발송됨.

3. **보호자가 지원 승인**
   - 보호자가 특정 지원자를 승인하면 `CareApplication` 상태가 `ACCEPTED`로 변경.
   - 나머지 지원자는 `REJECTED` 처리.
   - 승인/거절 알림 발송.

4. **채팅방 자동 생성**
   - 승인된 지원자와 보호자 간 1:1 채팅방(`Conversation`) 자동 생성.
   - `conversation_type = 'CARE_REQUEST'`
   - `related_type = 'CARE_APPLICATION'`, `related_idx = careApplication.idx`
   - 양쪽 모두 `ConversationParticipant`에 추가.

5. **채팅/협상**
   - 채팅방에서 메시지를 주고받으며 세부 조건을 협의.
   - 메시지 도착 시 실시간 알림.

6. **서비스 완료**
   - 서비스 완료 후 `CareRequest` 상태 `COMPLETED`로 변경.
   - 채팅방은 `CLOSED` 또는 계속 활성 상태 유지 가능.
   - 후기(`CareReview`) 작성 가능.

**참고**: 현재는 방안 A(댓글 기반)로 구현되어 있으며, 향후 방안 B(지원 승인 기반)로 전환 가능.

---

### 2. 1:1 일반 채팅 (DIRECT)

1. **사용자가 다른 사용자에게 채팅 요청**
   - 사용자 프로필에서 "채팅하기" 버튼 클릭.
   - 또는 기존 채팅방이 있는지 확인.

2. **채팅방 생성 또는 기존 채팅방 사용**
   - 기존 채팅방이 없으면 새로 생성: `conversation_type = 'DIRECT'`
   - 양쪽 사용자를 `ConversationParticipant`에 추가.

3. **메시지 주고받기**
   - 일반적인 1:1 대화.
   - 메시지 도착 시 알림.

---

### 3. 그룹 채팅 - 산책모임 (MEETUP)

1. **모임 생성**
   - 사용자가 산책모임(`Meetup`)을 생성.

2. **그룹 채팅방 자동 생성**
   - 모임 생성 시 그룹 채팅방 자동 생성.
   - `conversation_type = 'MEETUP'`
   - `related_type = 'MEETUP'`, `related_idx = meetup.idx`
   - `title = meetup.title` (모임 제목)
   - 주최자만 초기 참여자로 추가 (`ConversationParticipant`)
   - 주최자는 자동으로 `ADMIN` 역할.

3. **모임 참여**
   - 사용자가 모임에 참여 (`MeetupParticipants` 추가).
   - 모임 참여와 채팅 참여는 **분리**됨.
   - 모임 참여 완료 후 "채팅 참여하기" 버튼이 표시됨.

4. **채팅 참여 (수동)**
   - 사용자가 "채팅 참여하기" 버튼 클릭.
   - `ConversationParticipant`에 추가 (`status = 'ACTIVE'`).
   - 새로 참여한 사용자는 참여 시점 이후 메시지만 볼 수 있음.
     - `lastReadMessageIdx = null`, `lastReadAt = null`로 설정.
     - `joinedAt` 이후 메시지만 조회.

5. **채팅 참여 인원 표시**
   - 채팅방에 현재 참여 중인 인원 수 표시.
   - `ConversationParticipant` 중 `status = 'ACTIVE'`인 인원 수.

6. **그룹 대화**
   - 여러 참여자가 함께 대화.
   - 참여자별 읽지 않은 메시지 수 관리.
   - 참여 시점 이후 메시지만 조회 가능 (재참여 시 이전 대화 내용 못 봄).

7. **모임 참여 취소**
   - 사용자가 모임 참여 취소 시 채팅방에서도 **자동으로 나가기**.
   - `ConversationParticipant.status = 'LEFT'`, `leftAt` 설정.
   - 채팅방 참여 인원 수 자동 감소.

8. **채팅 재참여**
   - 모임 참여 후 다시 채팅 참여 버튼 클릭.
   - 기존 `ConversationParticipant`의 `status`를 `ACTIVE`로 변경.
   - `joinedAt` 업데이트.
   - `lastReadMessageIdx`, `lastReadAt` 초기화 (이전 대화 내용 못 봄).
   - 재참여 시점 이후 메시지만 조회 가능.

9. **모임 종료 시**
   - 채팅방은 `CLOSED` 또는 계속 활성 상태 유지 가능.

---

### 4. 실종제보 채팅 (MISSING_PET)

1. **실종제보 작성**
   - 사용자가 실종동물 제보(`MissingPetBoard`) 작성.
   - 채팅방은 아직 생성되지 않음 (목격자가 있을 때 생성).

2. **채팅 요청 ("목격했어요" 버튼 클릭)**
   - 다른 사용자가 "실종동물 목격했어요" 버튼 클릭.
   - 제보자와 목격자 간 1:1 채팅방 생성 또는 기존 채팅방 조회.
   - `conversation_type = 'MISSING_PET'`
   - `related_type = 'MISSING_PET_BOARD'`, `related_idx = missingPetBoard.idx`
   - 제보자 본인은 자신의 제보에 대해 채팅 시작 불가.

3. **중복 채팅방 방지**
   - 같은 제보에 대해 여러 목격자가 있을 수 있음.
   - 제보자-목격자 조합별로 개별 채팅방 생성.
   - 같은 제보자-목격자 조합에 대해 기존 채팅방이 있으면 재사용.
   - `related_idx`만으로는 구분 불가하므로, `ConversationParticipant`로 제보자와 목격자 모두 참여한 채팅방 확인.

4. **정보 교환**
   - 실종동물 관련 정보 주고받기.
   - 사진 공유 등.
   - 메시지 도착 시 실시간 알림.

5. **제보 해결 시**
   - 제보 상태가 `FOUND` 등으로 변경되면 채팅방은 계속 활성 상태 유지 가능.
   - 또는 채팅방 상태를 `CLOSED`로 변경 (선택사항).

---

### 5. 관리자 지원 채팅 (ADMIN_SUPPORT)

1. **사용자가 관리자에게 문의**
   - 사용자가 "관리자에게 문의하기" 버튼 클릭.

2. **채팅방 생성**
   - 사용자와 관리자 간 1:1 채팅방 생성.
   - `conversation_type = 'ADMIN_SUPPORT'`
   - `related_type = 'USER'`, `related_idx = userId`
   - 관리자는 `ADMIN` 역할.

3. **문의 및 답변**
   - 사용자가 문의, 관리자가 답변.
   - 답변 완료 후 채팅방 `CLOSED` 처리.

---

## WebSocket 실시간 채팅 구현 플로우

### 기술 스택
- **백엔드**: Spring WebSocket + STOMP Protocol
- **프론트엔드**: SockJS + STOMP.js
- **인증**: JWT Token (WebSocket 연결 시 전달)

### WebSocket 연결 설정

```
1. 클라이언트: WebSocket 연결 요청
   - URL: ws://localhost:8080/chat
   - 헤더에 JWT 토큰 포함
   
2. 서버: 연결 승인 및 인증
   - JWT 토큰 검증
   - 사용자 정보 추출
   - 연결 세션 저장 (사용자 ID → 세션 매핑)
   
3. 클라이언트: 연결 성공 시 채팅방 목록 조회
   - REST API: GET /api/chat/conversations
   - 활성 채팅방 목록 로드
```

### 채팅방 구독

```
1. 사용자가 채팅방 클릭
   → 채팅방 ID 확인

2. 해당 채팅방 구독
   → STOMP subscribe: /topic/conversation/{conversationId}
   
3. 서버: 구독 확인
   → 사용자가 해당 채팅방 참여자인지 검증
   → 참여자면 구독 승인

4. 최신 메시지 로드 (초기)
   → REST API: GET /api/chat/conversations/{conversationId}/messages
   → 페이징: 최신 50개 메시지
```

### 메시지 전송 플로우

```
1. 클라이언트: 메시지 입력 및 전송
   → STOMP send: /app/chat.send
   → Payload: { conversationId, content, messageType }
   
2. 서버: 메시지 처리
   a) ChatMessageService.sendMessage() 호출
   b) 전송자 검증 (참여자인지 확인)
   c) 메시지 저장 (ChatMessage 테이블)
   d) Conversation 메타데이터 업데이트
      - lastMessageAt 업데이트
      - lastMessagePreview 업데이트
   e) 참여자들의 읽지 않은 메시지 수 증가 (본인 제외)
   
3. 서버: 채팅방 참여자들에게 브로드캐스트
   → STOMP publish: /topic/conversation/{conversationId}
   → Payload: ChatMessageDTO
   
4. 클라이언트: 메시지 수신
   → 구독한 채팅방의 모든 참여자가 메시지 수신
   → UI에 즉시 메시지 표시
```

### 메시지 수신 플로우

```
1. 다른 사용자가 메시지 전송
   → 서버에서 처리 (메시지 전송 플로우 참고)

2. 서버: 채팅방 구독자에게 브로드캐스트
   → /topic/conversation/{conversationId}로 메시지 전송

3. 클라이언트: 실시간 메시지 수신
   → STOMP 메시지 리스너에서 수신
   → 채팅방이 현재 열려있으면 즉시 표시
   → 채팅방이 닫혀있으면:
     - 읽지 않은 메시지 수 증가 (뱃지 표시)
     - 알림 표시 (선택사항)

4. 읽지 않은 메시지 수 업데이트
   → ConversationParticipant.unreadCount 자동 증가 (서버에서)
   → 클라이언트는 채팅방 목록에서 실시간 업데이트
```

### 읽음 처리 플로우

```
1. 사용자가 채팅방 열기
   → 채팅방 메시지 조회
   
2. 메시지 읽음 처리
   → REST API: POST /api/chat/conversations/{conversationId}/read
   → 또는 WebSocket: /app/chat.read
   
3. 서버: 읽음 처리
   a) ConversationParticipant.unreadCount = 0
   b) ConversationParticipant.lastReadMessageIdx 업데이트
   c) ConversationParticipant.lastReadAt 업데이트
   d) MessageReadStatus 기록 (선택사항)
   
4. 다른 참여자에게 읽음 상태 전송 (선택사항)
   → /topic/conversation/{conversationId}/read
   → "사용자 A가 메시지를 읽었습니다" 알림
```

### 이미지/파일 전송 플로우

```
1. 클라이언트: 파일 선택
   → 이미지 또는 파일 선택

2. 파일 업로드
   → REST API: POST /api/files/upload
   → FileTargetType: CHAT_MESSAGE
   → 파일 업로드 후 filePath 반환

3. 메시지 전송 (파일 포함)
   → STOMP send: /app/chat.send
   → Payload: { 
       conversationId, 
       content: "[이미지]" 또는 "[파일]", 
       messageType: "IMAGE" 또는 "FILE",
       filePath: 업로드된 파일 경로
     }

4. 서버: 메시지 저장
   → ChatMessage 저장 (messageType, content)
   → AttachmentFile 연결 (targetType: CHAT_MESSAGE)

5. 메시지 브로드캐스트
   → 동일하게 모든 참여자에게 전송
```

### 연결 종료 플로우

```
1. 클라이언트: 페이지 이탈 또는 연결 종료
   → WebSocket 연결 자동 종료
   
2. 서버: 연결 종료 감지
   → WebSocketEventListener에서 처리
   → 사용자 세션 제거
   → 채팅방 구독 해제

3. 재연결 시
   → 자동 재연결 (SockJS 사용 시)
   → 또는 수동 재연결
   → 기존 채팅방 다시 구독
```

### 채팅방 생성 플로우 (WebSocket 연동)

```
1. 펫케어 지원 승인
   → CareApplication 상태가 ACCEPTED로 변경
   
2. 채팅방 생성
   → REST API: POST /api/chat/conversations
   → Conversation 생성
   → ConversationParticipant 생성 (양쪽 사용자)

3. 알림 전송 (SSE)
   → "채팅방이 생성되었습니다" 알림

4. 사용자가 채팅방 클릭
   → WebSocket 연결 (아직 안 되어있으면)
   → 채팅방 구독
   → 메시지 로드
```

### 타이핑 표시 플로우 (선택사항)

```
1. 사용자가 메시지 입력 중
   → WebSocket: /app/chat.typing
   → Payload: { conversationId, isTyping: true }

2. 서버: 다른 참여자에게 브로드캐스트
   → /topic/conversation/{conversationId}/typing
   → "사용자 A가 입력 중..."

3. 입력 중지 (3초 후 자동)
   → /app/chat.typing
   → Payload: { conversationId, isTyping: false }
```

### 에러 처리 플로우

```
1. 연결 실패
   → 자동 재연결 시도 (SockJS)
   → 3회 실패 시 사용자에게 알림
   
2. 메시지 전송 실패
   → 에러 메시지 표시
   → 재전송 버튼 제공 (로컬에 메시지 저장)

3. 인증 실패
   → 연결 거부
   → 로그인 페이지로 리다이렉트

4. 채팅방 권한 없음
   → 구독 거부
   → 에러 메시지 전송
```

### STOMP 엔드포인트 구조

```
**클라이언트 → 서버 (Send)**
/app/chat.send          # 메시지 전송
/app/chat.read          # 읽음 처리
/app/chat.typing        # 타이핑 표시 (선택)

**서버 → 클라이언트 (Subscribe)**
/topic/conversation/{conversationId}              # 채팅방 메시지
/topic/conversation/{conversationId}/typing      # 타이핑 표시
/topic/conversation/{conversationId}/read        # 읽음 상태
/user/{userId}/queue/messages                    # 개인 메시지/알림
```

### 성능 최적화

```
1. DB 인덱스 최적화
   → ChatMessage: (conversation_idx, created_at DESC) 인덱스
   → Conversation: (status, last_message_at DESC) 인덱스
   → ConversationParticipant: (user_idx, status) 인덱스
   → 메시지 조회는 DB에서 직접 처리 (캐싱 불필요)

2. 페이징 처리
   → 최신 50개 메시지만 로드
   → 무한 스크롤로 과거 메시지 로드
   → 커서 기반 페이징 사용

3. 메시지 배치 전송 (선택사항)
   → 여러 메시지를 한 번에 브로드캐스트

4. 연결 풀 관리
   → 사용자별 최대 연결 수 제한
   → 중복 연결 방지

5. 읽지 않은 메시지 수
   → ConversationParticipant 테이블에 저장
   → DB에서 직접 조회 (Redis 캐싱 불필요)
   → 실시간 업데이트

**주의**: 채팅 메시지는 자주 업데이트되므로 Redis 캐싱은 비효율적
→ DB 인덱스 최적화와 페이징으로 충분
```

## 공통 프로세스

### 채팅방 생성 공통 로직

```java
@Transactional
public Conversation createConversation(
    ConversationType type,
    RelatedType relatedType,
    Long relatedIdx,
    String title,
    List<Long> participantUserIds
) {
    // 1. Conversation 생성
    Conversation conversation = Conversation.builder()
        .conversationType(type)
        .relatedType(relatedType)
        .relatedIdx(relatedIdx)
        .title(title)
        .status(ConversationStatus.ACTIVE)
        .build();
    conversation = conversationRepository.save(conversation);
    
    // 2. 참여자 추가
    for (Long userId : participantUserIds) {
        ConversationParticipant participant = ConversationParticipant.builder()
            .conversation(conversation)
            .user(usersRepository.findById(userId).orElseThrow())
            .role(ParticipantRole.MEMBER)
            .status(ParticipantStatus.ACTIVE)
            .unreadCount(0)
            .build();
        participantRepository.save(participant);
    }
    
    // 3. 알림 발송
    for (Long userId : participantUserIds) {
        notificationService.createNotification(...);
    }
    
    return conversation;
}
```

### 메시지 전송 공통 로직

```java
@Transactional
public ChatMessage sendMessage(Long conversationIdx, Long senderIdx, String content, MessageType messageType) {
    // 1. 전송자 확인
    Users sender = usersRepository.findById(senderIdx).orElseThrow();
    if (sender.getIsDeleted()) {
        throw new IllegalStateException("탈퇴한 사용자는 메시지를 보낼 수 없습니다.");
    }
    
    // 2. 채팅방 확인
    Conversation conversation = conversationRepository.findById(conversationIdx).orElseThrow();
    ConversationParticipant senderParticipant = participantRepository
        .findByConversationIdxAndUserIdx(conversationIdx, senderIdx)
        .orElseThrow(() -> new IllegalArgumentException("채팅방 참여자가 아닙니다."));
    
    // 3. 메시지 저장
    ChatMessage message = ChatMessage.builder()
        .conversation(conversation)
        .sender(sender)
        .content(content)
        .messageType(messageType != null ? messageType : MessageType.TEXT)
        .build();
    message = chatMessageRepository.save(message);
    
    // 4. 참여자들의 읽지 않은 메시지 수 증가
    List<ConversationParticipant> participants = participantRepository
        .findByConversationIdxAndStatus(conversationIdx, ParticipantStatus.ACTIVE);
    
    for (ConversationParticipant p : participants) {
        if (!p.getUser().getIdx().equals(senderIdx)) {
            p.incrementUnreadCount();
            participantRepository.save(p);
        }
    }
    
    // 5. Conversation 메타데이터 업데이트
    conversation.setLastMessageAt(LocalDateTime.now());
    String preview = messageType == MessageType.IMAGE ? "[사진]" : 
                    messageType == MessageType.FILE ? "[파일]" : 
                    content.substring(0, Math.min(200, content.length()));
    conversation.setLastMessagePreview(preview);
    conversationRepository.save(conversation);
    
    // 6. 알림 발송
    for (ConversationParticipant p : participants) {
        if (!p.getUser().getIdx().equals(senderIdx) && !p.getUser().getIsDeleted()) {
            notificationService.createNotification(...);
        }
    }
    
    return message;
}
```

## 테이블 구조 설계

### 채팅 시스템 범용 구조 (확장 가능) ⭐ 권장
- 다양한 용도로 확장 가능
- 1:1, 그룹 채팅 모두 지원
- 폴리모픽 관계로 다양한 도메인 연결

---

## 채팅 시스템 범용 구조 (확장 가능) ⭐

### 핵심 설계 원칙

1. **다양한 채팅 타입 지원**: 1:1, 그룹, 관리자 등
2. **참여자 기반 관리**: ConversationParticipant 테이블로 다대다 관계
3. **폴리모픽 관계**: 다양한 도메인과 연결 가능
4. **참여자별 읽지 않은 메시지 수**: 개인화된 알림

### 1. Conversation (채팅방) 테이블 - 범용 구조

```sql
CREATE TABLE Conversation (
    idx BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 채팅방 타입
    conversation_type ENUM(
        'DIRECT',           -- 1:1 일반 채팅
        'GROUP',            -- 그룹 채팅
        'CARE_REQUEST',     -- 펫케어 요청 채팅
        'MISSING_PET',      -- 실종제보 채팅
        'MEETUP',           -- 산책모임 채팅
        'ADMIN_SUPPORT'     -- 관리자 지원 채팅
    ) NOT NULL,
    
    -- 채팅방 이름 (그룹 채팅용)
    title VARCHAR(200) NULL,
    
    -- 관련 엔티티 (폴리모픽 관계)
    related_type ENUM(
        'CARE_REQUEST',
        'CARE_APPLICATION',
        'MISSING_PET_BOARD',
        'MEETUP',
        'USER'
    ) NULL,
    related_idx BIGINT NULL,  -- 관련 엔티티 ID
    
    -- 상태
    status ENUM('ACTIVE', 'CLOSED', 'ARCHIVED') DEFAULT 'ACTIVE',
    
    -- 메타데이터
    last_message_at DATETIME NULL,
    last_message_preview VARCHAR(200) NULL,
    
    -- Soft Delete
    is_deleted BOOLEAN DEFAULT FALSE,
    deleted_at DATETIME NULL,
    
    -- 타임스탬프
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 제약조건
    -- related_type과 related_idx는 함께 NULL이거나 함께 NOT NULL
    CONSTRAINT chk_related_fields 
        CHECK ((related_type IS NULL AND related_idx IS NULL) 
               OR (related_type IS NOT NULL AND related_idx IS NOT NULL))
);

-- 인덱스
CREATE INDEX idx_conversation_type_status 
ON Conversation(conversation_type, status, last_message_at DESC);

CREATE INDEX idx_conversation_related 
ON Conversation(related_type, related_idx);

CREATE INDEX idx_conversation_deleted 
ON Conversation(is_deleted, deleted_at);
```

### 2. ConversationParticipant (채팅방 참여자) 테이블

```sql
CREATE TABLE ConversationParticipant (
    idx BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 관계
    conversation_idx BIGINT NOT NULL,
    user_idx BIGINT NOT NULL,
    
    -- 역할 (그룹 채팅에서 사용)
    role ENUM('MEMBER', 'ADMIN', 'MODERATOR') DEFAULT 'MEMBER',
    
    -- 읽지 않은 메시지 수
    unread_count INT DEFAULT 0,
    
    -- 마지막 읽은 메시지 ID (선택사항)
    last_read_message_idx BIGINT NULL,
    last_read_at DATETIME NULL,
    
    -- 참여 상태
    status ENUM('ACTIVE', 'LEFT', 'KICKED', 'MUTED') DEFAULT 'ACTIVE',
    
    -- 참여 시간
    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    left_at DATETIME NULL,
    
    -- Soft Delete
    is_deleted BOOLEAN DEFAULT FALSE,
    deleted_at DATETIME NULL,
    
    -- 타임스탬프
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 제약조건
    FOREIGN KEY (conversation_idx) REFERENCES Conversation(idx) ON DELETE CASCADE,
    FOREIGN KEY (user_idx) REFERENCES Users(idx),
    FOREIGN KEY (last_read_message_idx) REFERENCES ChatMessage(idx) ON DELETE SET NULL,
    
    -- 한 사용자는 같은 채팅방에 중복 참여 불가
    UNIQUE KEY uk_participant_conversation_user (conversation_idx, user_idx)
);

-- 인덱스
CREATE INDEX idx_participant_user_status 
ON ConversationParticipant(user_idx, status, unread_count DESC);

CREATE INDEX idx_participant_conversation 
ON ConversationParticipant(conversation_idx, status);

CREATE INDEX idx_participant_unread 
ON ConversationParticipant(user_idx, unread_count) WHERE unread_count > 0;
```

### 3. ChatMessage (채팅 메시지) 테이블 - 범용 구조

```sql
CREATE TABLE ChatMessage (
    idx BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 관계
    conversation_idx BIGINT NOT NULL,
    sender_idx BIGINT NOT NULL,
    
    -- 메시지 타입
    message_type ENUM('TEXT', 'IMAGE', 'FILE', 'SYSTEM', 'NOTICE') DEFAULT 'TEXT',
    
    -- 내용
    content TEXT NOT NULL,
    
    -- 메시지 참조 (답장 기능)
    reply_to_message_idx BIGINT NULL,
    
    -- Soft Delete
    is_deleted BOOLEAN DEFAULT FALSE,
    deleted_at DATETIME NULL,
    
    -- 타임스탬프
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 제약조건
    FOREIGN KEY (conversation_idx) REFERENCES Conversation(idx) ON DELETE CASCADE,
    FOREIGN KEY (sender_idx) REFERENCES Users(idx),
    FOREIGN KEY (reply_to_message_idx) REFERENCES ChatMessage(idx) ON DELETE SET NULL
);

-- 인덱스
CREATE INDEX idx_chat_message_conversation_created 
ON ChatMessage(conversation_idx, created_at DESC);

CREATE INDEX idx_chat_message_sender 
ON ChatMessage(sender_idx, created_at DESC);

CREATE INDEX idx_chat_message_type 
ON ChatMessage(message_type, created_at DESC);

CREATE INDEX idx_chat_message_deleted 
ON ChatMessage(is_deleted, deleted_at);

-- Full-Text 인덱스 (검색용)
CREATE FULLTEXT INDEX idx_chat_message_content 
ON ChatMessage(content);
```

### 4. MessageReadStatus (메시지 읽음 상태) 테이블

```sql
CREATE TABLE MessageReadStatus (
    idx BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 관계
    message_idx BIGINT NOT NULL,
    user_idx BIGINT NOT NULL,
    
    -- 읽은 시간
    read_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- 제약조건
    FOREIGN KEY (message_idx) REFERENCES ChatMessage(idx) ON DELETE CASCADE,
    FOREIGN KEY (user_idx) REFERENCES Users(idx),
    
    -- 한 사용자는 같은 메시지를 한 번만 읽음 처리
    UNIQUE KEY uk_message_read (message_idx, user_idx)
);

-- 인덱스
CREATE INDEX idx_read_status_user 
ON MessageReadStatus(user_idx, read_at DESC);

CREATE INDEX idx_read_status_message 
ON MessageReadStatus(message_idx);
```

## 범용 구조의 장점

### 1. 다양한 채팅 타입 지원

**1:1 일반 채팅:**
```java
Conversation conversation = Conversation.builder()
    .conversationType(ConversationType.DIRECT)
    .title(null)  // 1:1은 이름 없음
    .build();
```

**그룹 채팅 (산책모임):**
```java
Conversation conversation = Conversation.builder()
    .conversationType(ConversationType.MEETUP)
    .title("강남 산책 모임")
    .relatedType(RelatedType.MEETUP)
    .relatedIdx(meetupId)
    .build();
```

**펫케어 요청 채팅:**
```java
Conversation conversation = Conversation.builder()
    .conversationType(ConversationType.CARE_REQUEST)
    .title(null)
    .relatedType(RelatedType.CARE_APPLICATION)
    .relatedIdx(careApplicationId)
    .build();
```

### 2. 참여자 기반 관리

**채팅방 참여:**
```java
ConversationParticipant participant = ConversationParticipant.builder()
    .conversation(conversation)
    .user(user)
    .role(ParticipantRole.MEMBER)
    .status(ParticipantStatus.ACTIVE)
    .unreadCount(0)
    .build();
```

**채팅방 목록 조회:**
```java
@Query("SELECT c FROM Conversation c " +
       "INNER JOIN ConversationParticipant p ON c.idx = p.conversation.idx " +
       "WHERE p.user.idx = :userId " +
       "  AND p.status = 'ACTIVE' " +
       "  AND c.status = 'ACTIVE' " +
       "  AND c.isDeleted = false " +
       "ORDER BY c.lastMessageAt DESC")
List<Conversation> findMyConversations(@Param("userId") Long userId);
```

### 3. 참여자별 읽지 않은 메시지 수

**메시지 전송 시:**
```java
@Transactional
public ChatMessage sendMessage(Long conversationIdx, Long senderIdx, String content) {
    ChatMessage message = chatMessageRepository.save(...);
    
    // 참여자들의 읽지 않은 메시지 수 증가
    List<ConversationParticipant> participants = participantRepository
        .findByConversationIdxAndStatus(conversationIdx, ParticipantStatus.ACTIVE);
    
    for (ConversationParticipant p : participants) {
        if (!p.getUser().getIdx().equals(senderIdx)) {
            p.incrementUnreadCount();
            participantRepository.save(p);
        }
    }
    
    // Conversation 메타데이터 업데이트
    conversation.setLastMessageAt(LocalDateTime.now());
    conversation.setLastMessagePreview(content.substring(0, Math.min(200, content.length())));
    conversationRepository.save(conversation);
    
    return message;
}
```

**메시지 읽음 처리:**
```java
@Transactional
public void markAsRead(Long conversationIdx, Long userId, Long lastMessageIdx) {
    ConversationParticipant participant = participantRepository
        .findByConversationIdxAndUserIdx(conversationIdx, userId)
        .orElseThrow();
    
    // 읽지 않은 메시지 수 초기화
    participant.setUnreadCount(0);
    participant.setLastReadMessageIdx(lastMessageIdx);
    participant.setLastReadAt(LocalDateTime.now());
    participantRepository.save(participant);
    
    // MessageReadStatus 기록 (선택사항)
    if (lastMessageIdx != null) {
        MessageReadStatus readStatus = MessageReadStatus.builder()
            .message(chatMessageRepository.findById(lastMessageIdx).orElseThrow())
            .user(usersRepository.findById(userId).orElseThrow())
            .build();
        messageReadStatusRepository.save(readStatus);
    }
}
```

### 4. 다양한 도메인 연결 예시

**실종제보 채팅:**
```java
Conversation conversation = Conversation.builder()
    .conversationType(ConversationType.MISSING_PET)
    .relatedType(RelatedType.MISSING_PET_BOARD)
    .relatedIdx(missingPetBoardId)
    .build();
```

**관리자 지원 채팅:**
```java
Conversation conversation = Conversation.builder()
    .conversationType(ConversationType.ADMIN_SUPPORT)
    .relatedType(RelatedType.USER)
    .relatedIdx(userId)
    .build();
```

## 두 방안 비교

| 항목 | 방안 1 (전용) | 방안 2 (범용) |
|------|--------------|--------------|
| 구현 복잡도 | ⭐⭐ 간단 | ⭐⭐⭐⭐ 복잡 |
| 확장성 | ❌ 낮음 | ✅ 높음 |
| 그룹 채팅 | ❌ 불가능 | ✅ 가능 |
| 다양한 도메인 | ❌ 어려움 | ✅ 쉬움 |
| 성능 | ⭐⭐⭐⭐ 빠름 | ⭐⭐⭐ 빠름 |
| 유지보수 | ⭐⭐⭐⭐ 쉬움 | ⭐⭐⭐ 보통 |

## 권장 사항

### 초기 구현: 방안 1 (전용)
- 펫케어만 사용하는 경우
- 빠른 구현 필요
- 간단한 요구사항

### 확장 가능: 방안 2 (범용) ⭐
- 다양한 채팅 타입 필요
- 그룹 채팅 필요
- 향후 확장 예상
- **권장: 초기부터 범용 구조로 설계**

## 범용 구조로 마이그레이션

기존 방안 1에서 방안 2로 마이그레이션하는 방법:

1. **Conversation 테이블 수정**
   - `requester_idx`, `provider_idx` → `ConversationParticipant`로 이동
   - `conversation_type`, `related_type`, `related_idx` 추가

2. **데이터 마이그레이션**
   ```sql
   -- 기존 데이터를 새로운 구조로 변환
   INSERT INTO ConversationParticipant (conversation_idx, user_idx, role, status)
   SELECT idx, requester_idx, 'MEMBER', 'ACTIVE' FROM Conversation
   UNION ALL
   SELECT idx, provider_idx, 'MEMBER', 'ACTIVE' FROM Conversation;
   ```

3. **기존 컬럼 제거**
   - `requester_idx`, `provider_idx` 제거
   - `requester_unread_count`, `provider_unread_count` 제거

## 주요 개선 사항

### 1. CareApplication과의 연결
- `care_application_idx` 추가로 1:1 관계 명확화
- 지원하기 → CareApplication 생성 → Conversation 생성 플로우 반영

### 2. Soft Delete 패턴 적용
- 기존 프로젝트 패턴과 일치 (`is_deleted`, `deleted_at`)
- Conversation과 ChatMessage 모두 soft delete 지원

### 3. 메타데이터 추가
- `last_message_at`: 채팅방 목록 정렬 최적화
- `last_message_preview`: 목록에서 미리보기 표시
- 읽지 않은 메시지 수: ConversationParticipant 테이블에 저장 (DB 조회 최적화)

### 4. 읽음 처리 개선
- `is_read`: 읽음 여부
- `read_at`: 읽은 시간 기록

### 5. 타임스탬프
- `created_at`, `updated_at`: 기존 패턴과 일치

### 6. 인덱스 전략
- 채팅방 목록 조회 최적화 (사용자별, 상태별, 최신순)
- 메시지 조회 최적화 (채팅방별, 시간순)
- 읽지 않은 메시지 조회 최적화

## 다른 테이블과의 연동

### 1. File 테이블 확장

```sql
-- FileTargetType ENUM에 추가 필요
-- CHAT_MESSAGE 추가

-- 예시: 채팅 메시지에 이미지 첨부
-- attachment_file 테이블에:
-- target_type = 'CHAT_MESSAGE'
-- target_idx = chat_message.idx
```

### 2. Notification 테이블

```sql
-- NotificationType ENUM에 추가 필요
-- CHAT_MESSAGE 추가

-- 예시: 새 메시지 알림
-- type = 'CHAT_MESSAGE'
-- related_id = chat_message.idx
-- related_type = 'CHAT_MESSAGE'
```

## 비즈니스 로직 고려사항

### 1. 읽지 않은 메시지 수 관리

**방법 1: 실시간 계산 (초기 구현)**
```java
// Conversation 조회 시 계산
int unreadCount = chatMessageRepository.countByConversationAndIsReadFalse(conversation);
```

**방법 2: Conversation 테이블에 저장 (권장)**
```java
// 메시지 전송 시 업데이트
@Transactional
public ChatMessage sendMessage(Long conversationIdx, Long senderIdx, String content) {
    ChatMessage message = chatMessageRepository.save(...);
    
    // 읽지 않은 메시지 수 증가
    Conversation conversation = conversationRepository.findById(conversationIdx);
    if (senderIdx.equals(conversation.getRequesterIdx())) {
        conversation.incrementProviderUnreadCount();
    } else {
        conversation.incrementRequesterUnreadCount();
    }
    conversation.setLastMessageAt(message.getCreatedAt());
    conversation.setLastMessagePreview(content.substring(0, Math.min(200, content.length())));
    conversationRepository.save(conversation);
    
    return message;
}

// 메시지 읽음 처리 시
@Transactional
public void markAsRead(Long conversationIdx, Long readerIdx) {
    // 읽지 않은 메시지 모두 읽음 처리
    chatMessageRepository.markAsRead(conversationIdx, readerIdx);
    
    // 읽지 않은 메시지 수 초기화
    Conversation conversation = conversationRepository.findById(conversationIdx);
    if (readerIdx.equals(conversation.getRequesterIdx())) {
        conversation.setRequesterUnreadCount(0);
    } else {
        conversation.setProviderUnreadCount(0);
    }
    conversationRepository.save(conversation);
}
```

### 2. Conversation 생성 플로우

```java
@Transactional
public CareApplication createApplication(Long careRequestId, Long applicantId, String message) {
    // 1. CareApplication 생성
    CareApplication application = CareApplication.builder()
        .careRequest(careRequest)
        .applicant(applicant)
        .message(message)
        .status(CareApplicationStatus.PENDING)
        .build();
    application = careApplicationRepository.save(application);
    
    // 2. Conversation 생성
    Conversation conversation = Conversation.builder()
        .careRequest(careRequest)
        .careApplication(application)
        .requesterIdx(careRequest.getUser().getIdx())
        .providerIdx(applicant.getIdx())
        .status(ConversationStatus.ACTIVE)
        .build();
    conversationRepository.save(conversation);
    
    // 3. 알림 발송
    notificationService.createNotification(...);
    
    return application;
}
```

### 3. 메시지 삭제 (Soft Delete)

```java
@Transactional
public void deleteMessage(Long messageIdx, Long userId) {
    ChatMessage message = chatMessageRepository.findById(messageIdx)
        .orElseThrow();
    
    // 본인 메시지만 삭제 가능
    if (!message.getSenderIdx().equals(userId)) {
        throw new IllegalArgumentException("본인 메시지만 삭제할 수 있습니다.");
    }
    
    // Soft Delete
    message.setIsDeleted(true);
    message.setDeletedAt(LocalDateTime.now());
    chatMessageRepository.save(message);
}
```

## 성능 최적화

### 1. 읽지 않은 메시지 수 관리
- Conversation 테이블에 저장하여 JOIN 없이 조회 가능
- 메시지 전송/읽음 시에만 업데이트

### 2. 채팅방 목록 조회
```sql
-- 인덱스 활용
SELECT * FROM Conversation
WHERE requester_idx = ? OR provider_idx = ?
  AND status = 'ACTIVE'
  AND is_deleted = FALSE
ORDER BY last_message_at DESC;
```

### 3. 메시지 조회 (페이징)
```sql
-- 커서 기반 페이징 (권장)
SELECT * FROM ChatMessage
WHERE conversation_idx = ?
  AND is_deleted = FALSE
  AND created_at < ?
ORDER BY created_at DESC
LIMIT 50;
```

## 사용자 탈퇴 처리 전략

### 문제 상황
- 사용자가 탈퇴(`users.is_deleted = true`)할 때 채팅 관련 데이터 처리 필요
- 채팅 히스토리는 보존해야 하지만, 탈퇴한 사용자 정보는 표시하지 않아야 함
- FK 제약조건 때문에 완전 삭제는 불가능 (soft delete 방식)

### 해결 방안

#### 1. FK 제약조건 유지 (Soft Delete 방식)

```sql
-- FK는 그대로 유지 (ON DELETE 제약 없음)
FOREIGN KEY (requester_idx) REFERENCES Users(idx),
FOREIGN KEY (provider_idx) REFERENCES Users(idx),
FOREIGN KEY (sender_idx) REFERENCES Users(idx)

-- 이유: 
-- - Users 테이블이 soft delete이므로 실제로 삭제되지 않음
-- - FK 제약조건은 유지되지만 데이터는 보존됨
```

#### 2. 조회 시 탈퇴한 사용자 필터링

**채팅방 목록 조회:**
```java
// 탈퇴하지 않은 사용자의 채팅방만 조회
@Query("SELECT c FROM Conversation c " +
       "JOIN Users requester ON c.requesterIdx = requester.idx " +
       "JOIN Users provider ON c.providerIdx = provider.idx " +
       "WHERE (c.requesterIdx = :userId OR c.providerIdx = :userId) " +
       "  AND requester.isDeleted = false " +
       "  AND provider.isDeleted = false " +
       "  AND c.status = 'ACTIVE' " +
       "  AND c.isDeleted = false " +
       "ORDER BY c.lastMessageAt DESC")
List<Conversation> findActiveConversationsByUser(@Param("userId") Long userId);
```

**메시지 조회:**
```java
// 메시지는 그대로 조회하되, 탈퇴한 사용자는 "탈퇴한 사용자"로 표시
public ChatMessageDTO toDTO(ChatMessage message) {
    Users sender = message.getSender();
    ChatMessageDTO dto = new ChatMessageDTO();
    
    if (sender.getIsDeleted()) {
        // 탈퇴한 사용자 처리
        dto.setSenderName("탈퇴한 사용자");
        dto.setSenderProfileImage(null);
        dto.setIsDeletedSender(true);
    } else {
        dto.setSenderName(sender.getUsername());
        dto.setSenderProfileImage(sender.getProfileImageUrl());
        dto.setIsDeletedSender(false);
    }
    
    dto.setContent(message.getContent());
    dto.setCreatedAt(message.getCreatedAt());
    return dto;
}
```

#### 3. 탈퇴한 사용자의 채팅방 숨김

**Conversation 조회 로직:**
```java
// 탈퇴한 사용자가 포함된 채팅방은 조회에서 제외
public List<ConversationDTO> getMyConversations(Long userId) {
    // 1. 현재 사용자가 참여하는 채팅방 조회
    List<Conversation> conversations = conversationRepository
        .findByRequesterIdxOrProviderIdx(userId, userId);
    
    // 2. 탈퇴한 사용자가 포함된 채팅방 제외
    return conversations.stream()
        .filter(conv -> {
            Users requester = usersRepository.findById(conv.getRequesterIdx()).orElse(null);
            Users provider = usersRepository.findById(conv.getProviderIdx()).orElse(null);
            
            // 둘 다 탈퇴하지 않았거나, 내가 탈퇴하지 않은 경우만
            boolean requesterActive = requester != null && !requester.getIsDeleted();
            boolean providerActive = provider != null && !provider.getIsDeleted();
            boolean iAmActive = (conv.getRequesterIdx().equals(userId) && requesterActive) ||
                               (conv.getProviderIdx().equals(userId) && providerActive);
            
            return requesterActive && providerActive && iAmActive;
        })
        .map(this::toDTO)
        .collect(Collectors.toList());
}
```

#### 4. 메시지 전송 시 탈퇴 체크

```java
// 메시지 전송 시
@Transactional
public ChatMessage sendMessage(Long conversationIdx, Long senderIdx, String content) {
    // 1. 전송자가 탈퇴했는지 확인
    Users sender = usersRepository.findById(senderIdx)
        .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다."));
    
    if (sender.getIsDeleted()) {
        throw new IllegalStateException("탈퇴한 사용자는 메시지를 보낼 수 없습니다.");
    }
    
    Conversation conversation = conversationRepository.findById(conversationIdx)
        .orElseThrow();
    
    // 2. 채팅방의 다른 사용자가 탈퇴했는지 확인
    Long receiverIdx = conversation.getRequesterIdx().equals(senderIdx) 
        ? conversation.getProviderIdx() 
        : conversation.getRequesterIdx();
    
    Users receiver = usersRepository.findById(receiverIdx).orElse(null);
    
    if (receiver == null || receiver.getIsDeleted()) {
        throw new IllegalStateException("대화 상대가 존재하지 않거나 탈퇴했습니다.");
    }
    
    // 3. 메시지 저장
    ChatMessage message = chatMessageRepository.save(
        ChatMessage.builder()
            .conversation(conversation)
            .sender(sender)
            .content(content)
            .isRead(false)
            .build()
    );
    
    // 4. Conversation 메타데이터 업데이트
    conversation.setLastMessageAt(LocalDateTime.now());
    conversation.setLastMessagePreview(content.substring(0, Math.min(200, content.length())));
    
    if (senderIdx.equals(conversation.getRequesterIdx())) {
        conversation.incrementProviderUnreadCount();
    } else {
        conversation.incrementRequesterUnreadCount();
    }
    conversationRepository.save(conversation);
    
    // 5. 탈퇴하지 않은 사용자에게만 알림 발송
    notificationService.createNotification(
        receiverIdx,
        NotificationType.CHAT_MESSAGE,
        "새 메시지가 도착했습니다",
        message.getContent(),
        conversationIdx,
        "CONVERSATION"
    );
    
    return message;
}
```

#### 5. 탈퇴 시 채팅방 자동 비활성화 (선택사항)

```java
// 사용자 탈퇴 처리 시
@Transactional
public void deactivateUserConversations(Long userId) {
    // 해당 사용자가 참여하는 모든 채팅방 비활성화
    List<Conversation> conversations = conversationRepository
        .findByRequesterIdxOrProviderIdx(userId, userId);
    
    for (Conversation conv : conversations) {
        conv.setStatus(ConversationStatus.CLOSED);
        conversationRepository.save(conv);
    }
}
```

### 쿼리 최적화

**탈퇴한 사용자 체크를 JOIN으로 처리:**
```sql
-- 채팅방 목록 조회 (탈퇴한 사용자 제외)
SELECT c.* 
FROM Conversation c
INNER JOIN Users requester ON c.requester_idx = requester.idx
INNER JOIN Users provider ON c.provider_idx = provider.idx
WHERE (c.requester_idx = ? OR c.provider_idx = ?)
  AND requester.is_deleted = FALSE
  AND provider.is_deleted = FALSE
  AND c.status = 'ACTIVE'
  AND c.is_deleted = FALSE
ORDER BY c.last_message_at DESC;
```

**인덱스 추가:**
```sql
-- 탈퇴 체크 최적화
CREATE INDEX idx_users_deleted ON Users(is_deleted, idx);
```

### 요약

✅ **FK 제약조건 유지**: Soft delete 방식이므로 실제 삭제되지 않아 FK 문제 없음
✅ **조회 시 필터링**: 탈퇴한 사용자 포함 채팅방은 목록에서 제외
✅ **메시지 표시**: 탈퇴한 사용자 메시지는 "탈퇴한 사용자"로 표시
✅ **메시지 전송 차단**: 탈퇴한 사용자는 메시지 전송 불가
✅ **알림 차단**: 탈퇴한 사용자에게는 알림 발송 안 함
✅ **채팅방 자동 비활성화**: 탈퇴 시 관련 채팅방 CLOSED 처리 (선택)

### 구현 체크리스트

- [ ] FK 제약조건에서 ON DELETE 옵션 명시하지 않기 (soft delete 유지)
- [ ] 채팅방 목록 조회 시 탈퇴한 사용자 필터링 (JOIN으로 처리)
- [ ] 메시지 DTO 변환 시 탈퇴한 사용자 체크 및 "탈퇴한 사용자" 표시
- [ ] 메시지 전송 시 전송자/수신자 탈퇴 여부 체크
- [ ] 알림 발송 시 수신자 탈퇴 여부 체크
- [ ] 사용자 탈퇴 시 관련 채팅방 자동 비활성화 (선택)
- [ ] 인덱스 추가: `idx_users_deleted` (성능 최적화)

## 추가 고려사항

### 선택사항 (향후 구현)

1. **메시지 타입 확장**
   ```sql
   -- ChatMessage에 추가 가능
   message_type ENUM('TEXT', 'IMAGE', 'FILE', 'SYSTEM') DEFAULT 'TEXT'
   ```

2. **읽음 확인 (Read Receipt)**
   - 현재: `is_read`, `read_at`으로 기본 구현
   - 향후: 실시간 읽음 확인 (WebSocket)

3. **채팅방 나가기**
   - `status = 'CLOSED'`로 처리
   - 또는 별도 필드: `left_at`, `left_by`

4. **메시지 검색**
   ```sql
   -- Full-Text 인덱스
   CREATE FULLTEXT INDEX idx_chat_message_content 
   ON ChatMessage(content);
   ```

5. **대화방 아카이빙**
   - 오래된 대화방 자동 아카이빙
   - 읽은 메시지만 보관 (미읽음 메시지는 유지)

